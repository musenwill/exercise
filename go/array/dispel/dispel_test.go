package dispel

import (
	"testing"
)

type caze struct {
	lst []int
	exp int64
}

func TestDispel(t *testing.T) {
	cases := []caze{
		{[]int{2, 1, 3}, 2},
		{[]int{0}, 0},
		{[]int{1}, 0},
		{[]int{9, 8, 7, 6, 5, 4, 3, 2, 1}, 20},
		{[]int{1, 3, 2, 0, 3}, 3},
	}

	for _, v := range cases {
		act := minimumValueAfterDispel(v.lst)
		if act != v.exp {
			t.Errorf("got %v expected %v of %v", act, v.exp, v.lst)
		}
	}
}

/*
题目描述
题目背景：

“曾经有两次消除的机会摆在我面前，我却没有珍惜……”牛牛回忆道。

牛牛正在玩一款全新的消消乐游戏。这款游戏的主体是由一列列的方块构成，牛牛的目标就是要尽量消除这些方块。

每次操作，牛牛可以选择某个高度 x，将所有高度大于等于 x 的那些列全部消除 x 个方块，随后方块会下落，以填补消除造成的空白。

牛牛这一局的发挥极佳，眼看就要破纪录了，却发现自己只剩下了两次消除机会。

为了不错失这千载难逢的机会，他决定写个程序来算出最优解。


简明题意：

给定一个数组 nums，其中有 n 个非负整数。你的目的是进行两次操作，使得数组的元素之和最小。
每次操作形如：任选一个整数 x ，将数组中所有大于等于 x 的数减去 x 。

示例1
输入
复制
[2, 1, 3]
输出
复制
0
说明
初始数组为 [2, 1, 3]。
先选择 x = 2，则所有大于等于 2 的元素减去 2 ，变成 [0, 1, 1]。
再选择 x = 1，则所有大于等于 1 的元素减去 1 ，变成 [0, 0, 0]。
所以数组元素之和的最小值为 0。
备注:
对于所有的测试数据，保证有1\leq n \leq 30001≤n≤3000 且 0\leq num_i \leq 2^{31}-10≤num
i
​
 ≤2
31
 −1 。
*/
